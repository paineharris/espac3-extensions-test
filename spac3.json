{
  "README.md": " ",
  "main.blocks": "<xml xmlns=\"https://developers.google.com/blockly/xml\"/>",
  "main.ts": "/**\n * Use VARIABLE.min=number and VARIABLE.max=number\n * to specify a range on a parameter. Drag the foo\n * block and try to change the value!\n */\n\n//% color=\"#FFAB19\"\nenum Choice {\n    Z,\n    X,\n    Y\n    }\nconst groupA = [pos(0, 0, 0),pos(0, 0, 0)]\n\nenum Choice1 {\n   groupA\n    }\nnamespace spac3 {\n    \n    //% block=\"from%p3=minecraftCreatePosition|to %p4=minecraftCreatePosition|set as a group %groupA\"\n    //% inlineInputMode=external\n    export function newgroup<T>(p3: Position, p4: Position) :any[]{\n    let groupA = [world(0, 0, 0), world(0, 0, 0)]\n    const numb = Math.abs(p3.getValue(0)-p4.getValue(0))+Math.abs(p3.getValue(1)-p4.getValue(1))+Math.abs(p3.getValue(2)-p4.getValue(2))\n    for (let i = 0; i < Math.abs(p3.getValue(0)-p4.getValue(0))+1; i++) {\n        player.say(\":)\");\n        if(i==0)\n        {\n        player.say(\":)\")\n        groupA[i]= world(p3.getValue(0)+i,p3.getValue(1),p3.getValue(2));\n        }\n        else{\n            player.say(\":)\");\n            groupA[i]=world(p3.getValue(0)+i,p3.getValue(1),p3.getValue(2));\n            \n        }\n   }\n    for (let i = 0; i < Math.abs(p3.getValue(1)-p4.getValue(1))+1; i++) {\n        if(i==0){\n        groupA[i]=world(p3.getValue(0),p3.getValue(1)+i,p3.getValue(2));\n        }\n        else{\n        groupA[i]=world(p3.getValue(0),p3.getValue(1)+i,p3.getValue(2));\n            }\n   }\n    for (let i = 0; i < Math.abs(p3.getValue(2)-p4.getValue(2))+1; i++) {\n        if(i==0){\n        groupA[i]=world(p3.getValue(0),p3.getValue(1)+i,p3.getValue(2)+i);\n        }\n        else{\n            groupA[i]=world(p3.getValue(0),p3.getValue(1)+i,p3.getValue(2)+i)\n        }\n   }\n    return groupA;\n    }\n    \n    \n    \n    //% block=\"from%p3=minecraftCreateWorldPosition|to %p4=minecraftCreateWorldPosition|move x:%x|y:%y|z:%z\"\n    //% inlineInputMode=external\n    export function movebyTrue(p3: Position, p4: Position, x: number, y: number, z: number) {\n        const p5 = positions.add(p3, pos(x, y, z))\n\t    cloneAll(p3, p4, p5, true)\n    }\n  \n\n    //% block=\"from%p3=minecraftCreatePosition|to %p4=minecraftCreatePosition|move x:%x|y:%y|z:%z\"\n    //% inlineInputMode=external\n    export function moveby(p3: Position, p4: Position, x: number, y: number, z: number) {\n        let p3w = positions.add(player.position(), p3)\n        let p4w = positions.add(player.position(), p4)\n        movebyTrue(p3w, p4w, x, y, z)\n    }\n\n    //% block=\"from%p0=minecraftCreatePosition|to %p1=minecraftCreatePosition|moveto %p2=minecraftCreatePosition||\"\n    //% inlineInputMode=external\n    export function moveto(p0: Position, p1: Position, p2: Position) {\n        let p0w = positions.add(player.position(), p0)\n        let p1w = positions.add(player.position(), p1)\n        movetoTrue(p0w, p1w, p2);\n    }\n    //% block=\"from%p0=minecraftCreateWorldPosition to %p1=minecraftCreateWorldPosition|moveto %p2=minecraftCreateWorldPosition||\"\n    //% inlineInputMode=external    \n    export function movetoTrue(p0: Position, p1: Position, p2: Position) {\n        cloneAll(p0, p1, p2, true);\n    }\n\n    export function cloneAll(p0: Position, p1: Position, p2: Position, isMove: boolean = false, rotateQuarter: number = 0){\n        let dx = p2.getValue(0) - p0.getValue(0)\n        let dy = p2.getValue(1) - p0.getValue(1)\n        let dz = p2.getValue(2) - p0.getValue(2)\n        let normalizedRotateQuarter = rotateQuarter % 4\n        iterateCube(p0, p1, (p: Position) => {\n            agent.setAssist(DESTROY_OBSTACLES, true)\n            let directions = [pos(1, 0, 0), pos(0, 0, 1), pos(-1, 0, 0), pos(0, 0, -1)]\n            let facings = [WEST, NORTH, EAST, SOUTH]\n            let reverseFacings = [EAST, SOUTH, WEST, NORTH]\n\n            let dest = positions.add(p, pos(dx, dy, dz))\n            for (let i = 0; i < 4; i++) {\n                let neighborPosition = positions.add(p, directions[i])\n                let needRecover = false\n                let done = false\n                let neighborBlock\n                if (isCube(neighborPosition)) {\n                    agent.teleport(p, reverseFacings[i])\n                    neighborBlock = agent.inspect(AgentInspection.Block, FORWARD)\n                    agent.destroy(FORWARD)\n                    needRecover = true\n                }\n                agent.teleport(positions.add(p, directions[i]), facings[i])\n                if (agent.detect(AgentDetection.Block, FORWARD)) {\n                    let b = agent.inspect(AgentInspection.Block, FORWARD)\n                    if (isMove) agent.destroy(FORWARD)\n                    let r = (i + rotateQuarter) % 4\n                    for (let j = 0; j < 4; j++) {\n                        agent.teleport(positions.add(dest, directions[j]), facings[j])\n                        if (agent.detect(AgentDetection.Block, FORWARD)) {\n                            agent.destroy(FORWARD)\n                            break\n                        }\n                    }\n                    agent.teleport(positions.add(dest, directions[r]), facings[r])\n                    agent.setItem(b, 1, 1)\n                    agent.place(FORWARD)\n                    done = true                \n                }\n                if (needRecover) {\n                    blocks.place(neighborBlock, neighborPosition)\n                }\n                if (done) {\n                    break\n                }\n            }\n        })\n    }\n\n    export function isCube(p: Position): boolean {\n            let directions = [pos(1, 0, 0), pos(0, 0, 1), pos(-1, 0, 0), pos(0, 0, -1)]\n            let facings = [WEST, NORTH, EAST, SOUTH]\n            let sum = 0;\n            for (let i = 0; i < 4; i++) {\n                agent.teleport(positions.add(p, directions[i]), facings[i])\n                if (agent.detect(AgentDetection.Block, FORWARD)) {\n                    sum++\n                }\n            }\n            return sum == 4\n    }\n\n    export function iterateCube(p1: Position, p2: Position, handler: (p: Position)=>void) {\n        let minx = Math.min(p1.getValue(0), p2.getValue(0))\n        let maxx = Math.max(p1.getValue(0), p2.getValue(0))\n        let miny = Math.min(p1.getValue(1), p2.getValue(1))\n        let maxy = Math.max(p1.getValue(1), p2.getValue(1))\n        let minz = Math.min(p1.getValue(2), p2.getValue(2))\n        let maxz = Math.max(p1.getValue(2), p2.getValue(2))\n        let start: Position = positions.add(p1, pos(minx - p1.getValue(0), miny - p1.getValue(1), minz - p1.getValue(2)))\n        for (let i = 0; i <= maxx - minx; i++)\n            for (let j = 0; j <= maxy - miny; j++)\n                for (let k = 0; k <= maxz - minz; k++) {\n                    handler(positions.add(start, pos(i, j, k)))\n                }\n    }\n\n    export function calcuNewpos(p0: Position, p1: Position ,x:Axis,y:number):Position{\n        let  a = world(0,0,0)\n        if(x== 0){\n            a= world(p0.getValue(0), \n            (p0.getValue(1) - p1.getValue(1))*Math.cos(3.1415926*y/180) - (p0.getValue(2) - p1.getValue(2))*Math.sin(3.1415926*y/180) + p1.getValue(1),      \n            (p0.getValue(1) - p1.getValue(1))*Math.sin(3.1415926*y/180) + (p0.getValue(2) - p1.getValue(2))*Math.cos(3.1415926*y/180) + p1.getValue(2))\n        }\n        else if(x==1){\n            a= world(( p0.getValue(0) - p1.getValue(0))*Math.cos(3.1415926*y/180) - (p0.getValue(2) - p1.getValue(2))*Math.sin(3.1415926*y/180) + p1.getValue(0),\n            p0.getValue(1),\n            (p0.getValue(0) - p1.getValue(0))*Math.sin(3.1415926*y/180) + (p0.getValue(2) - p1.getValue(2))*Math.cos(3.1415926*y/180) + p1.getValue(2))\n        }\n        else if(x==2){\n            a= world(( p0.getValue(0) - p1.getValue(0))*Math.cos(3.1415926*y/180) - (p0.getValue(1) - p1.getValue(1))*Math.sin(3.1415926*y/180) + p1.getValue(0),\n            (p0.getValue(0) - p1.getValue(0))*Math.sin(3.1415926*y/180) + (p0.getValue(1) - p1.getValue(1))*Math.cos(3.1415926*y/180) + p1.getValue(1),\n            p0.getValue(2))\n        }\n        return(a)\n\n\n    }\n    //% block=\"from %p0=minecraftCreateWorldPosition to %p1=minecraftCreateWorldPosition|rotate on %p2=minecraftCreateWorldPosition|along %x|by %degree|degrees\"\n    //% inlineInputMode=external\n    export function rotateTrue( p0: Position, p1: Position, p2: Position, x:Axis, degrees:number){\n        while (degrees < 0) {\n            degrees += 360\n        }\n        let rotateQuarter = degrees / 90\n        let normalizedDegrees = rotateQuarter * 90\n        iterateCube(p0, p1, (p: Position) => {\n            let newp = calcuNewpos(p, p2, x, normalizedDegrees)\n            cloneAll(p, p, newp, true, rotateQuarter)\n        })\n    }\n\n    //% block=\"from %p0=minecraftCreatePosition to %p1=minecraftCreatePosition|rotate on %p2=minecraftCreatePosition|along %x|by %degree|degrees\"\n    //% inlineInputMode=external\n    export function rotate( p0: Position, p1: Position, p2: Position, x:Axis, degrees:number){\n        let p0w = positions.add(player.position(), p0)\n        let p1w = positions.add(player.position(), p1)\n        let p2w = positions.add(player.position(), p2)\n        rotateTrue(p0w, p1w, p2w, x, degrees)\n    }\n\n    export function calcuRefpos(p0: Position,y:number,x:Choice):Position{\n        let  a = world(0,0,0)\n        if(x== Choice.Z){\n            a= world(p0.getValue(0),p0.getValue(1),y*2-p0.getValue(2))\n            player.say(a)\n        }\n        else if(x==Choice.X){\n            a= world(y*2-p0.getValue(0),p0.getValue(1),p0.getValue(2))\n            player.say(a)\n        }\n        else if(x==Choice.Y){\n            a= world(p0.getValue(0),y*2-p0.getValue(1),p0.getValue(2))\n            player.say(a)\n        }\n        return(a)\n\n\n    }\n\n    //% block=\"from %p0=minecraftCreateWorldPosition to %p1=minecraftCreateWorldPosition|reflect on %x| = %y|pad\"\n    //% inlineInputMode=external\n    export function reflectTrue( p0: Position, p1: Position, x:Choice, y:number){\n        iterateCube(p0, p1, (p: Position) => {\n            let rotateQuarter = 0\n            let directions = [pos(1, 0, 0), pos(0, 0, 1), pos(-1, 0, 0), pos(0, 0, -1)]\n            let facings = [WEST, NORTH, EAST, SOUTH]\n            let reverseFacings = [EAST, SOUTH, WEST, NORTH]\n\n            for (let i = 0; i < 4; i++) {\n                let neighborPosition = positions.add(p, directions[i])\n                let needRecover = false\n                let done = false\n                let neighborBlock\n                if (isCube(neighborPosition)) {\n                    agent.teleport(p, reverseFacings[i])\n                    neighborBlock = agent.inspect(AgentInspection.Block, FORWARD)\n                    agent.destroy(FORWARD)\n                    needRecover = true\n                }\n                agent.teleport(positions.add(p, directions[i]), facings[i])\n                if (agent.detect(AgentDetection.Block, FORWARD)) {\n                    if ((x == Choice.X && (facings[i] == WEST || facings[i] == EAST)) ||\n                        (x == Choice.Z && (facings[i] == NORTH || facings[i] == SOUTH))) {\n                        rotateQuarter = 2\n                    }\n                    done = true\n                }\n                if (needRecover) {\n                    blocks.place(neighborBlock, neighborPosition)\n                }\n                if (done) {\n                    break\n                }\n            }\n\n            let newp = calcuRefpos(p, y, x)\n            cloneAll(p, p, newp, false, rotateQuarter)\n        })\n    }\n\n    //% block=\"from %p0=minecraftCreatePosition to %p1=minecraftCreatePosition|reflect on %x| = %y|pad\"\n    //% inlineInputMode=external\n    export function reflect( p0: Position, p1: Position, x:Choice, y:number){\n        let p0w = positions.add(player.position(), p0)\n        let p1w = positions.add(player.position(), p1)\n        reflectTrue(p0w, p1w, x, y)    \n    }\n }",
  "pxt.json": "{\n    \"name\": \"spac3\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"2.0.2\",\n        \"pxt\": \"5.35.4\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"
}